# ScalaCheck

What sets ScalaCheck apart from numerous mainstream testing tool is its core idea, the concept of *property-based* testing.

The idea is that if you are rigid enough about testing and write tests for covering most parts of your implementation.
You should then be able to put less focus on your informal specification documents and instead start considering the tests themselves a specification for your program.

However, while the idea of tests as specification is to make your specification more test-centered, property-based testing goes in the opposite direction by making your tests more specification-like.
It does so by generalizing *tests to properties*.

### Tests versus properties

A test is a concrete example of how a program should behave in a particular situation, while a property is an abstract, general specification.

Still, the tests don't really describe the method's behavior; they merely give us a number of usage examples.
A *property*, on the other hand, will give us a more general description of the behavior.

You can read the property and get a *complete* definition of the behavior, rather than a set of examples that only indicates the method's behavior.

There is not much more to property-based testing than this.
Simply replace a set of concrete test cases with one abstract property that describes a code unit's behavior.
ScalaCheck will then take your abstract property and turn it into possibly thousands of concrete test cases by generating randomized dat for the property's parameters.
It will run each test in an attempt to *falsify* the property, and only if each test for a given property passes will ScalaCheck regard the property as true.

Remember also that everything that is offered by traditional, example-based tests still is viable in a property-based setting.
Since properties just are a generalization of tests, you can write properties that make use of concrete tests instead of, or in combination with, ones that are generated by ScalaCheck.
Property-based testing simply gives you new ways of expressing expectations on your code, it doesn't remove anything you are used to from example-based testing.

### Benefits from property-based testing

**Test coverage** can increase since test cases are generated in a random fashion, and the code is tested with many more cases.
Since you can control the distribution of generated test cases in ScalaCheck and collect statistics on the kind of data that has been used, you can get reliable test coverage if you write your properties with care.

**Specification completeness** is easier to accomplish with ScalaCheck than with JUnit.
In ScalaCheck, you often have a chance to define exactly how your code should behave.
This can be useful not only because it enables better testing, but also because it forces you to reflect about your code's exact behavior.
It makes it harder to skip over edge cases in your tests, in your implementation, and in your thinking.

## ScalaCheck versus JUnit

### Using ScalaCheck

In ScalaCheck, you define *properties* instead of tests.
To define a set of properties for our library under test, we extend `org.scalacheck.Properties` class, which could be seen as corresponding to the `TestCase` class in JUnit.

The `Prop.forAll` method is a common way of creating properties in ScalaCheck.
The forAll method takes an anonymous function as its parameter, and that function in turn takes parameters that are used to express a boolean condition.
Basically, the `forAll` method is equivalent to what in logic is called a *universal quantifier*.
When ScalaCheck tests a property created with the `forAll` method, it tries to *falsify* it by assigning different values to the parameters of the provided function, and evaluating the boolean result.
If it can't locate a set of arguments that makes the property false, then ScalaCheck will regard the property as *passed*.

```scala
def alphaStr: Gen[String]
```
Generates a string of alpha characters

```scala
def numChar: Gen[Char]
```
Generates a numerical character

Which types are available for use in a `forAll` property?
ScalaCheck has built-in support for common Java and Scala types, so you can use ordinary types like integers, strings, dates, lists, arrays, and so on.
However, you can also add support for any custom data type, by letting ScalaCheck know how to generate your type.

For each property, ScalaCheck prints the test results, starting with an exclamation mark for failed properties and a plus sign for properties that passed the tests.

## ScalaCheck Fundamentals

The two most fundamental concepts in ScalaCheck are *properties* and *generators*.

This chapter will introduce the classes that represent properties in ScalaCheck, and bring up some technical details about the API.

Generators are the other important part of ScalaCheck's core.
A generator is responsible for producing the data passed as input to a property during ScalaCheck's verification phase.

### The `Prop` and `Properties` classes

A single property in ScalaCheck is the smallest testable unit.
It is always represented by an instance of the `org.scalacheck.Prop` class.

The common way of creating property instances is by using the various methods from the `org.scalacheck.Prop` module.

The second property uses `Prop.throws` that creates a property that tries to run a given statement each time the property is evaluated.
Only if the statement throws the specified exception the property passes.

When defining several related properties, ScalaCheck also has a class named `org.scalacheck.Properties` that can be used to group a bunch of properties together.
It provides a way to label the individual property instances, and makes it easier for ScalaCheck to present the test results in a nice way.
Using the `Properties` class is the preferred way of defining properties for your code.

### Generators

#### The `Gen` class

A generator can be described simply as a function that takes some generation parameters and produces a value.
In ScalaCheck, generators are represented by the `Gen` class, and the essence of this class looks like this:

#### Defining custom generators

As I've mentioned, there are many methods you can use to create your own generators in the `Gen` module.
These methods are called *combinators*, since you can use them as basic building blocks for generating more complex structures and classes.
To combine them together, you use Scala's versatile *for* statement, which is mostly used in loop constructs but in fact is much more general.

As I've said, data generators are not exclusively related to properties; you can use the `Gen` module as an API for defining data generators for any setting really.

#### Making explicit use of generators in properties

However, you can instruct ScalaCheck explicitly to use a certain generator in a property definition.
You can use `Prop.forAll` with one extra parameter to inform ScalaCheck which generator to use:
```scala
import org.scalacheck.{Gen, Prop}

val evenInt = for {
  n <- Gen.choose(-1000, 1000)
} yield 2 * n

val propDivide = Prop.forAll(evenInt) { n: Int =>
  val half = n / 2
  n == 2 * half
}
```

#### Adding implicit support for custom generators

However, you can also add implicit support for your own generators so you can write properties for your own classes in exactly the same way you would for the standard types, without explicitly specifying which generator to use in every property.

## Designing Properties

The concept of a property is not hard to grasp; it's basically a boolean expression.
The difficulty lies in transforming the ideas you have about your program's behavior into formal properties suitable for ScalaCheck's verification machinery.

### Incomplete properties

However, it can be hard to immediately come up with a ScalaCheck property that completely describes all behavioral aspects that you want to specify.
Therefore, it is often easier to write properties in an iterative fashion.

Start out with simple facts that you know always should hold true for your code.
A starting question you can ask yourself is: What would be totally unacceptable?

Properties like the ones above can act as a great support when you're starting out development of a piece of code, or when refactoring existing code.
They provide definite boundaries for your implementations.
Later on you can extend your properties with more complete conditions or simply add more properties, to cover more aspects of the functionality.

### Relation properties

A special form of incomplete properties are relation properties.
Instead of specifying a unit of code against one input instance at a time, you can use two or more test cases in the same property and base your specification on the relation between the inputs.

### Reference implementations

One technique for writing complex specifications is to use a *reference implementation*.
Instead of writing down the direct conditions that should hold, you make an indirect specification by relating your implementation to a known working one.
The reference implementation can either be a well-used and tested one from a standard library, or a simple proof-of-concept implementation that you've written from scratch without any considerations other than correctness.
The trusted reference implementation can be used to test that another, perhaps performance-optimized, version behaves correctly.

### Restricting test cases

Since ScalaCheck borrows much from logic when it comes to writing specifications, preconditions are specified as implications with the `==>` operator.
You must import `Prop.BooleanOperators` to make this operator available.
This module contains implicit methods that extend boolean values with various property-related operators and methods.

When ScalaCheck tests this property, it skips over the cases where the precondition is not fulfilled, and regards them as *discarded*.
Discarded test cases are not included in the total sum of passed tests for a property, which means that if the precondition is hard to fulfill when generating random test data, ScalaCheck might not be able to verify the property at all.

## Running ScalaCheck

### Retrieving ScalaCheck

#### Using Maven

If you use Maven, you can get it to fetch ScalaCheck automatically by including the following dependency:
```xml
<repositories>
	<repository>
		<id>oss.sonatype.org</id>
		<name>releases</name>
		<url>http://oss.sonatype.org/content/repositories/releases</url>
	</repository>
</repositories>

<dependencies>
	<dependency>
		<groupId>org.scalacheck</groupId>
		<artifactId>scalacheck_2.12</artifactId>
		<version>1.13.4</version>
		<scope>test</scope>
	</dependency>
</dependencies>
```

### Integrating ScalaCheck

#### Using ScalaCheck with ScalaTest

ScalaTest provides two ways in its `org.scalatest.prop` package to incorporate ScalaCheck property checks into your test suites: `Checkers` and `PropertyChecks`.
`Checkers` allows you to use native ScalaCheck syntax;
`PropertyChecks` provides syntax more consistent with the rest of ScalaTest.

`Checkers` therefore allows you to construct properties the same was as ScalaCheck, and obtain output consistent with running ScalaCheck directly.

ScalaTest's `forAll` can be optionally configured by specifying arguments before the property function.
