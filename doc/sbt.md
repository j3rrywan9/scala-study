# sbt

## Chapter 1. Why sbt?

### How sbt works

Let's take a quick look at how sbt works.
sbt consists of two things: tasks and settings.

#### sbt tasks

sbt is built around tasks.

You want to do something, you execute a task.
You want to ensure that a task runs after another task, you add an explicit dependency between the tasks.

If you want to use the results of a task in another task, you push the output from one task into another.
The results of one task are automatically available in dependent tasks.
The output of an sbt task is a value (which can be of any type), so this can be passed around with ease.
Multiple tasks can depend on the output of the same task.
By default, sbt runs all of the tasks in parallel, but by using the dependency tree, it can work out what should be sequential and what can be parallel.

sbt puts in place a default structure and layout.
Out of the box you get your `compile` task, `test` task, and `publish` task, and these work as expected: if you run the `test` task, sbt will run the `compile` task beforehand.
The `compile` task compiles Scala and Java by default.
The layout is similar to that of a standard Maven project.

A task in sbt is Scala code.
You write the code directly in your build configuration.
This gives you all of the power of Scala in your build and avoids lots of portability problems.

#### sbt settings

A setting in sbt is just a value.

### Passing information around your build

In sbt, you can simply return the information from the first task as the return value fo the task.

You know that the task has executed because you have the value.

### Working with Scala

#### Cross-compilation for multiple Scala versions

Scala (the library) is binary-compatible between minor version releases.

sbt has built-in options for this sort of thing.
You can tell sbt to cross-compile directly in the build definition.

#### Lots more classes in Scala

The Scala compiler tends to generate more classes (.class files) than would be generated by the equivalent program written in Java.
This is due to how Scala generates code for closures and other constructs that aren't supported directly in the JVM, which it must simulate.
The concrete effect is that the JVM takes longer to get up and running with Scala code—and not only on compilation but on test startup as well.

### Multiproject builds

sbt is also designed specifically for multiproject (sometimes called multimodule) builds.

### Dependency resolution

sbt uses Ivy for its dependency resolution.

## Chapter 2. Getting started

### Setting up sbt

Everything needed to run sbt is in the sbt/bin directory.
This directory consists of the actual sbt launcher and convenience scripts that provide easier configuration of the Java runtime.
The sbt/bin directory must be placed in the PATH to use sbt via the command line.

#### Running sbt

By default, sbt includes only the bare minimum it needs to launch builds.
The first time you run a project, sbt needs to download the remaining portions required, as well as compile the local project's build definition.
This process happens only the first time a dependency is needed or when your build changes.

### Setting up a build

Every project using sbt should have two files:
* project/build.properties
* build.sbt

The *build.properties* file is used to inform sbt which version it should use for your build, and the *build.sbt* file defines the actual settings for your build.

#### Tasks

Tasks are things that sbt build can do for you, like compiling a project, creating documentation, or running tests.

#### Settings

Run the `settings` help on the sbt command line and see if that points you to to where source code for the project should go
```
> settings

This is a list of settings defined for the current project.
It does not list the scopes the settings are defined in; use the 'inspect' command for that.

  baseDirectory                  The base directory.  Depending on the scope, this is the base directory for the build, project, configuration, or task.
  classDirectory                 Directory for compiled classes and copied resources.
  javaSource                     Default Java source directory.
  libraryDependencies            Declares managed dependencies.
  managedResourceDirectories     List of managed resource directories.
  name                           Project name.
  organization                   Organization/group ID.
  publishArtifact                Enables (true) or disables (false) publishing an artifact.
  resourceDirectory              Default unmanaged resource directory, used for user-defined resources.
  scalaSource                    Default Scala source directory.
  scalaVersion                   The version of Scala used for building.
  sourceDirectories              List of all source directories, both managed and unmanaged.
  sourceDirectory                Default directory containing sources.
  target                         Main directory for files generated by the build.
  unmanagedBase                  The default directory for manually managed libraries.
  unmanagedResourceDirectories   Unmanaged resource directories, containing resources manually created by the user.
  unmanagedSourceDirectories     Unmanaged source directories, which contain manually created sources.

More settings may be viewed by increasing verbosity.  See 'help settings'
```
Again, there are a lot of default settings.
We'll make another note to return here when needed and focus on the goal of adding some source code.
Because we're into the Scala language, let's look more at the following `scalaSource` setting (for those interested in Java, the `javaSource` setting provides the same function as `scalaSource`):
```
> scalaSource
[info] progfun / Compile / scalaSource
[info] 	/Users/jwang/scala-notes/progfun/src/main/scala
[info] Compile / scalaSource
[info] 	/Users/jwang/scala-notes/src/main/scala
```

### Running code

In sbt, running code can take on a few different flavors.

#### Interacting with code in the interpreter

One of the greatest advantages offered in sbt is the ability to explore a project through the Scala REPL (a.k.a Scala console or Scala interpreter).
This provides a command-line interface where you can directly construct classes, call methods, and see what happens.

### Testing code

#### Make sure to reload

Any change to the *build.sbt* file or files in the *project/* directory won't be immediately available within the sbt console.
The `reload` command tells sbt to re-examine the project definition and rewire the project.
When you edit an sbt build, you'll need to reload.

## Chapter 3. Core concepts

### Creating builds

Let's look at the `build.properties` file you defined:
```sbt
sbt.version=1.3.4
```
Although this file can be used to specify several things, it's commonly used only to specify the sbt version.

The core of the build is its `build.sbt` file.

Every sbt build is created by defining a group of settings, projects, and definitions.

### Defining settings

Settings are the bread and butter of sbt builds.
They're the mechanism by which you configure sbt to perform the work you need for your build.
sbt reads all the settings defined in your build at load time and runs their initializations, which produce the final setting values used for your build.

A setting consists of three parts: a key, an initialization, and an operator that associates the key and initialization.
A setting is used to change an aspect of the build or add functionality.

> Typesafe settings
>
> In sbt, every key has one and only one type.
> Any value placed into a setting must match the exact type.
> This prevents mismatched data from being passed around the build.

> Defining dependencies
>
> sbt provides a convenient syntax for defining dependencies on remote artifacts using the `%` method.
> This method is used to create `ModuleID` instances.
> To define a `ModuleID` in sbt, write `"groupId" % "artifactId" % "version"` and it will automatically become an instance of a `ModuleID`.

The `libraryDependencies` key holds a value of type `Seq[ModuleID]`.
The `+=` operator is used to take the previous value assigned to the `libraryDependencies` setting and append the new `ModuleID` value to it.

There are two operators to append values to existing settings that contain a sequence of items: `+=` and `++=`.
The `++=` operator works similarly to the `+=` operator, but instead of adding a single value, it adds multiple values given as a sequence.

#### Initializations

In sbt, an initialization is a Scala expression that can produce a value, and it may use other settings to do so.

An *initialization* is an expression that produces a value and may use other settings to do so.
You can access the value of another setting using the `value` method.

### Creating and executing tasks

Builds are about accomplishing tasks, from running a compiler to generating zip files for distribution.
Tasks are the means to repeatedly perform some operation, like compiling your project, generating documentation, or running tests.
In sbt a task is like a setting that runs every time you request its value.
That is, every time you make a request to sbt's task engine, each task required will be run once for that request.

### Defining with  subprojects

In sbt, the default project settings assume that each project has its own base directory.
Each project in your build should have its own base directory that's different from any other project.
Within this base directory, you'll find the directories for source code, testing code, and so on.

The root directory is the default target for settings found in the `build.sbt` file.
This means that all the configuration you have so far for testing applies only to code in the root project.

Project dependencies are defined using the `dependsOn` method of `Project`.

#### Project definition order matters!

Just like any other Scala object, any values defined can't be referenced before they're declared.
Because of this, it drastically simplifies life to declare projects using `lazy val`s.
It's such a common issue with circular references that we recommend always using `lazy val`s to define projects.

## The default build

### Compiling your code

One of the primary purposes of a build tool is to compile code.
But in order to compile code, sbt first needs to know a few things.
You can ask sbt what it needs using the `inspect tree` command on the sbt prompt.

As shown in this more easily readable tree, compilation requires three things:
* A sequence (list) of source files
* A sequence (list) of libraries
* A sequence (list) of compiler configuration options

### Finding your sources

As it does for many other aspects of a build, sbt applies certain conventions when looking for your source code.
But you can easily customize the way sources are organized, if necessary

#### Standard organization of sources

You can see that the list of sources is taken from two aggregates:
* **unmanagedSources** - A discovered list of source files using standard project conventions
* **managedSources** - A list of sources that are either generated from the build or manually added

For sbt, the unmanaged sources are discovered by convention.
Unmanaged means you (not sbt) have to do the work of adding, modifying, and tracking the source files, whereas managed source files are ones that sbt will create and track for you.

Unmanaged sources make use of a set of file filters and a default set of directories to produce the sequence of source files for the project.
As shown in the dependency tree, the directories defined by the `javaSource` and `scalaSource` settings make up the set of directories where sbt looks for sources.

#### Testing sources

Besides these main sources, many projects contain other kinds of source files.
The most prominent ones are the test source files, which contain code to test your software but will never enter production.
Typical examples include unit tests written using a testing library like ScalaTest, ScalaCheck, or JUnit.
Of course, there can also be test resources, files that won't be compiled but are needed at the time of test execution as is.

To delineate the different dimensions of sources, sbt places the *compile source file* settings into a configuration called `Compile` and the *test source file* settings into a configuration called `Test`.
You can inspect the dependency tree for test sources by running the `inspect tree test:sources` command in the sbt shell:
```sbt
inspect tree test:sources
```
You may notice that the test:sources task uses the exact same lookup as the `compile:sources` task.
That's because under the covers, sbt is using the same set of settings to find your source files.
sbt does this same thing with the resources task, creating settings for configuring testing resources under the `test:resources` task.

#### Custom organization of sources

The lowest setting in the tree, `sourceDirectory`, which has type `File` in the Global configuration scope (`*`), is defined to be `src/`.
By default it depends on another setting of type File: `baseDirectory`, which points to the base directory of your project.
`sourceDirectory` points to a new `src` child directory underneath the project's `baseDirectory`.

### Depending on libraries

The dependencies are split into two parts:
* **Internal dependencies** - These are the dependencies between projects defined in the current sbt build.
* **External dependencies** - These are dependencies that must be pulled from somewhere outside, via Ivy or the filesystem.

Whereas internal dependencies are calculated using the project `dependsOn` method, external dependencies are a bit more involved.
They’re further split into the following two components:
* **Unmanaged dependencies** - These are external dependencies sbt discovers from default locations.
* **Managed dependencies** - These are external dependencies you specify in the sbt build.
These dependencies are resolved by the `update` task.

#### Unmanaged dependencies

#### Managed dependencies

The recommended approach to library dependencies is using managed dependencies.
If you’ve been using Maven, Gradle, or some other advanced build tool, the concept of declarative library management won't be new.
sbt's managed dependencies are similar: you declare one or more library dependencies in the build definition, and sbt will download these from a repository and put these on the classpath when needed.

The most important setting to know about IvySbt is the `resolvers` setting.
This is where you can specify how and where to find libraries.
Although Ivy supports configurable lookup mechanisms, most projects make use of sbt's default, which is to load from a Maven repository.

The `libraryDependencies` setting is defined as a collection of `ModuleID` values.
`ModuleID` is an sbt abstraction to simplify the declaration of dependencies.

`ModuleID` consists of three mandatory values: `organization`, `name`, and `revision`.
These are Ivy's variants of Maven's `groupId`, `artifactId`, and `version` attributes and are a way to uniquely identify a library.

In sbt, you can define a module ID using the `%` method against strings.
Simply specify the organization, name, and revision separated by `%`.

When it comes to dependencies on Scala libraries, you need to pay special attention to binary compatibility.
You have to use a version of the library that was compiled against the same or at least a binary-compatible version of Scala, like the one we're using for our project.

sbt has established a de facto standard where the Scala version is encoded in the `name` of the library by name mangling.
Actually, it's not the full Scala version that's added to the `name` but only the Scala binary version, which by default consists of the major and minor version numbers; for example, 2.10.

Therefore, sbt offers a convenient and safe way to declare dependencies on cross-compiled Scala libraries.
Instead of the `%` operator, you use the `%%` operator between the `organization` and `name` and omit adding the Scala binary version to the name:
```sbt
libraryDependencies ++= Seq(
  "com.typesafe" %% "scalalogging-slf4j" % "0.4.0",
  "ch.qos.logback" % "logback-classic" % "1.0.7"
)
```
This is as easy as before, and sbt will automatically create a `ModuleID`, which has a name mangled with the Scala binary version.

#### Managed dependencies and configurations

```sbt
libraryDependencies ++= Seq(
  "org.scalatest" %% "scalatest" % "3.0.5" % "test"
)
```
You append the name of the Test configuration to the library dependency, using an additional `%` operator to define the configuration.
By default, all dependencies are put onto the default configuration, used for both running and compiling all code in your project.

### Packaging your project

The default sbt build is oriented around open source JVM libraries.
This means that, by default, sbt will package your project as reusable jar files that can be published to Ivy or Maven repositories and consumed by others.
Publishing to Ivy or Maven requires a few things:
* A jar file containing the library to share
* A jar file containing the source code of the shared library
* A jar file containing the documentation (Scaladoc or Javadoc) of the shared library
* A configuration file (pom.xml or ivy.xml) that identifies the project and where it came from

